{"version":3,"file":"SocketConnectionProvider.js","sources":["../src/SocketConnectionProvider.tsx"],"sourcesContent":["\"use client\";\n\nimport {\n  PropsWithChildren,\n  ReactNode,\n  createContext,\n  useCallback,\n  useContext,\n  useEffect,\n  useMemo,\n  useRef,\n} from \"react\";\n\ninterface State {\n  addListener: (func: Function) => void;\n  removeListener: (func: Function) => void;\n  initConnection: (token?: string) => () => void;\n}\n\nconst initialState: State = {\n  addListener: () => {},\n  removeListener: () => {},\n  initConnection: (token?: string) => () => {},\n};\n\nconst Context = createContext<State>(initialState);\n\nconst SOCKET_URL = `${process.env.NEXT_PUBLIC_WSS_URL}`;\n\nexport function SocketConnectionProvider({\n  children,\n}: {\n  children: ReactNode;\n}) {\n  const listeners = useRef<Function[]>([]);\n  const timerRef = useRef<NodeJS.Timer>();\n\n  const addListener = useCallback<State[\"addListener\"]>(\n    (func) => listeners.current.push(func),\n    []\n  );\n  const removeListener = useCallback<State[\"removeListener\"]>((func) => {\n    const index = listeners.current.indexOf(func);\n    if (index !== -1) {\n      listeners.current.splice(index, 1);\n    }\n  }, []);\n\n  const initConnection = useCallback<State[\"initConnection\"]>(\n    (token?: string) => {\n      let ws: WebSocket;\n\n      const connectWs = () => {\n        ws = new WebSocket(SOCKET_URL);\n\n        const user_random_id = Math.floor(Math.random() * 1000000);\n\n        ws.onopen = () => {\n          ws.send(\n            JSON.stringify({\n              type: \"socket\",\n              token: token ?? user_random_id,\n            })\n          );\n\n          clearInterval(timerRef.current as any);\n\n          timerRef.current = setInterval(() => {\n            if (ws.readyState !== WebSocket.CLOSED) {\n              ws.send(\n                JSON.stringify({\n                  type: \"ping\",\n                })\n              );\n            } else {\n              clearInterval(timerRef.current as any);\n            }\n          }, 50000);\n        };\n\n        ws.onmessage = (event) => {\n          listeners.current.forEach((func) => {\n            if (typeof func === \"function\") {\n              func(event);\n            }\n          });\n        };\n\n        ws.onclose = (event) => {\n          // console.error(`WS closed with code ${event.code}`);\n        };\n      };\n\n      connectWs();\n\n      return () => {\n        clearInterval(timerRef.current as any);\n\n        if (ws) {\n          ws.close();\n        }\n      };\n    },\n    []\n  );\n\n  const state = useMemo<State>(\n    () => ({ addListener, removeListener, initConnection }),\n    [addListener, initConnection, removeListener]\n  );\n\n  return <Context.Provider value={state}>{children}</Context.Provider>;\n}\n\nexport const useSocketEvents = (\n  onMessage: (data: MessageEvent<any>) => void\n) => {\n  const { addListener, removeListener, initConnection } = useContext(Context);\n\n  useEffect(() => {\n    addListener(onMessage);\n\n    return () => removeListener(onMessage);\n  }, [addListener, onMessage, removeListener]);\n\n  return { initSocketConnection: initConnection };\n};\n"],"names":[],"mappings":";;;;AAmBA;AACE;AACA;;;AAIF;AAEA;AAEgB;AAKd;AACA;;AAMA;;AAEE;;;;AAKF;AAEI;;AAGE;AAEA;AAEA;AACE;AAEI;AACA;AACD;AAGH;AAEA;;AAEI;AAEI;AACD;;;AAGH;;;AAGN;AAEA;;AAEI;;;AAGF;AACF;AAEA;;AAEA;AACF;AAEA;AAEA;AACE;;;;AAKF;;;;AAWN;AAEa;AAGX;;;AAKE;;AAGF;AACF;;"}